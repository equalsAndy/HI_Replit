/**
 * Report Quality Monitor
 * ======================
 * METAlia service focused specifically on monitoring and improving report quality
 */

import { Pool } from 'pg';
import { conversationLoggingService } from './conversation-logging-service.js';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

export interface ReportQualityIssue {
  reportId: string;
  userId: number;
  issueType: 'generic_template' | 'missing_data' | 'low_personalization' | 'data_mismatch';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  reportLength: number;
  hasUserData: boolean;
  hasSpecificPercentages: boolean;
  hasPersonalizedContent: boolean;
  detectedAt: Date;
}

export class ReportQualityMonitor {

  /**
   * Analyze a generated report for quality issues
   */
  async analyzeReportQuality(
    reportContent: string,
    userId: number,
    reportType: 'personal' | 'professional',
    userAssessmentData: any
  ): Promise<ReportQualityIssue[]> {
    const issues: ReportQualityIssue[] = [];
    const reportId = `report-${userId}-${Date.now()}`;

    // Check 1: Is it just a generic template?
    if (this.isGenericTemplate(reportContent)) {
      issues.push({
        reportId,
        userId,
        issueType: 'generic_template',
        severity: 'critical',
        description: 'Report appears to be a generic template without user-specific data',
        reportLength: reportContent.length,
        hasUserData: false,
        hasSpecificPercentages: false,
        hasPersonalizedContent: false,
        detectedAt: new Date()
      });
    }

    // Check 2: Does it use actual user assessment data?
    const hasActualData = this.usesActualUserData(reportContent, userAssessmentData);
    if (!hasActualData && userAssessmentData) {
      issues.push({
        reportId,
        userId,
        issueType: 'missing_data',
        severity: 'high',
        description: 'Report does not incorporate available user assessment data',
        reportLength: reportContent.length,
        hasUserData: false,
        hasSpecificPercentages: this.hasSpecificPercentages(reportContent),
        hasPersonalizedContent: this.hasPersonalizedContent(reportContent),
        detectedAt: new Date()
      });
    }

    // Check 3: Does it have specific percentages from user's actual StarCard?
    if (!this.hasSpecificPercentages(reportContent)) {
      issues.push({
        reportId,
        userId,
        issueType: 'low_personalization',
        severity: 'medium',
        description: 'Report lacks specific percentage data from user StarCard assessment',
        reportLength: reportContent.length,
        hasUserData: hasActualData,
        hasSpecificPercentages: false,
        hasPersonalizedContent: this.hasPersonalizedContent(reportContent),
        detectedAt: new Date()
      });
    }

    // Check 4: Does it reference user's specific examples/quotes?
    if (!this.hasPersonalizedContent(reportContent)) {
      issues.push({
        reportId,
        userId,
        issueType: 'low_personalization',
        severity: 'medium',
        description: 'Report lacks personalized content with user-specific examples',
        reportLength: reportContent.length,
        hasUserData: hasActualData,
        hasSpecificPercentages: this.hasSpecificPercentages(reportContent),
        hasPersonalizedContent: false,
        detectedAt: new Date()
      });
    }

    // Log quality issues to METAlia
    if (issues.length > 0) {
      await this.logQualityIssues(reportId, issues);
      await this.createEscalationForPoorReport(reportId, userId, issues);
    }

    return issues;
  }

  /**
   * Check if report is just a generic template
   */
  private isGenericTemplate(reportContent: string): boolean {
    const genericIndicators = [
      'Taylor Smith', // Default template name
      'Acting: 35%', // Generic percentages
      'You possess a unique combination of strengths that shapes how you naturally approach',
      'Generated by AllStarTeams Workshop | AST v2.1.0'
    ];

    let genericCount = 0;
    for (const indicator of genericIndicators) {
      if (reportContent.includes(indicator)) {
        genericCount++;
      }
    }

    // If it has 2+ generic indicators, it's likely a template
    return genericCount >= 2;
  }

  /**
   * Check if report uses actual user assessment data
   */
  private usesActualUserData(reportContent: string, userAssessmentData: any): boolean {
    if (!userAssessmentData) return false;

    // Look for user's actual StarCard percentages
    if (userAssessmentData.starCard) {
      const { thinking, feeling, acting, planning } = userAssessmentData.starCard;
      
      // Check if any of the user's actual percentages appear in the report
      const thinkingPercent = ((thinking / 100) * 100).toFixed(1);
      const feelingPercent = ((feeling / 100) * 100).toFixed(1);
      const actingPercent = ((acting / 100) * 100).toFixed(1);
      const planningPercent = ((planning / 100) * 100).toFixed(1);

      if (reportContent.includes(thinkingPercent) || 
          reportContent.includes(feelingPercent) ||
          reportContent.includes(actingPercent) ||
          reportContent.includes(planningPercent)) {
        return true;
      }
    }

    // Look for user's actual reflection content
    if (userAssessmentData.reflections) {
      for (const reflection of Object.values(userAssessmentData.reflections)) {
        if (typeof reflection === 'string' && reflection.length > 20) {
          // Check if any meaningful part of user's reflection is quoted
          const words = reflection.split(' ').slice(0, 5).join(' ');
          if (reportContent.includes(words)) {
            return true;
          }
        }
      }
    }

    return false;
  }

  /**
   * Check if report has specific percentages (not generic ones)
   */
  private hasSpecificPercentages(reportContent: string): boolean {
    // Generic percentages that indicate template usage
    const genericPercentages = ['35%', '25%', '20%', '30%'];
    
    for (const generic of genericPercentages) {
      if (reportContent.includes(generic)) {
        return false; // Found generic percentage
      }
    }

    // Look for any percentage with decimal places (more specific)
    const specificPercentagePattern = /\d+\.\d+%/;
    return specificPercentagePattern.test(reportContent);
  }

  /**
   * Check if report has personalized content
   */
  private hasPersonalizedContent(reportContent: string): boolean {
    const personalizationIndicators = [
      'you mentioned',
      'your example of',
      'you described',
      'you reflected',
      'your response about',
      'you shared',
      'you explained'
    ];

    for (const indicator of personalizationIndicators) {
      if (reportContent.toLowerCase().includes(indicator)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Log quality issues to METAlia database
   */
  private async logQualityIssues(reportId: string, issues: ReportQualityIssue[]): Promise<void> {
    try {
      for (const issue of issues) {
        await conversationLoggingService.logConversation({
          personaType: 'star_report',
          userId: issue.userId,
          sessionId: reportId,
          userMessage: `Report quality analysis for user ${issue.userId}`,
          taliaResponse: `Quality issue detected: ${issue.issueType} - ${issue.description}`,
          contextData: {
            reportQualityIssue: true,
            issueType: issue.issueType,
            severity: issue.severity,
            reportLength: issue.reportLength,
            hasUserData: issue.hasUserData,
            hasSpecificPercentages: issue.hasSpecificPercentages,
            hasPersonalizedContent: issue.hasPersonalizedContent
          },
          requestData: {
            reportId,
            qualityAnalysis: true,
            requestTimestamp: new Date().toISOString()
          },
          responseMetadata: {
            confidence: 0.9,
            source: 'metalia_quality_monitor',
            tokensUsed: 0
          },
          conversationOutcome: issue.severity === 'critical' ? 'escalated' : 'completed'
        });
      }

      console.log(`üìä METAlia: Logged ${issues.length} quality issues for report ${reportId}`);
    } catch (error) {
      console.error('‚ùå Error logging quality issues:', error);
    }
  }

  /**
   * Create escalation for poor quality reports
   */
  private async createEscalationForPoorReport(
    reportId: string, 
    userId: number, 
    issues: ReportQualityIssue[]
  ): Promise<void> {
    try {
      const criticalIssues = issues.filter(i => i.severity === 'critical');
      
      if (criticalIssues.length > 0) {
        await conversationLoggingService.createEscalation({
          requestingPersona: 'star_report',
          escalationType: 'error_report',
          priority: 'high',
          question: `Poor quality report generated for user ${userId}. Issues detected: ${issues.map(i => i.issueType).join(', ')}`,
          contextData: {
            reportId,
            userId,
            issues: issues.map(i => ({
              type: i.issueType,
              severity: i.severity,
              description: i.description
            }))
          },
          userMessage: `Report quality analysis for user ${userId}`,
          attemptedResponse: `Report contained ${issues.length} quality issues`
        });

        console.log(`üö® METAlia: Created escalation for poor quality report ${reportId}`);
      }
    } catch (error) {
      console.error('‚ùå Error creating quality escalation:', error);
    }
  }

  /**
   * Get report quality statistics
   */
  async getQualityStatistics(days: number = 7): Promise<any> {
    try {
      const conversations = await conversationLoggingService.getConversations({
        personaType: 'star_report',
        startDate: new Date(Date.now() - days * 24 * 60 * 60 * 1000),
        endDate: new Date(),
        limit: 1000
      });

      const qualityIssues = conversations.filter(c => 
        c.context_data?.reportQualityIssue === true
      );

      const issueTypes = qualityIssues.reduce((acc, issue) => {
        const type = issue.context_data?.issueType || 'unknown';
        acc[type] = (acc[type] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      const severityCounts = qualityIssues.reduce((acc, issue) => {
        const severity = issue.context_data?.severity || 'unknown';
        acc[severity] = (acc[severity] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      return {
        totalReports: conversations.length,
        reportsWithIssues: qualityIssues.length,
        qualityRate: ((conversations.length - qualityIssues.length) / conversations.length * 100).toFixed(1),
        issueTypes,
        severityCounts,
        timeRange: `${days} days`
      };
    } catch (error) {
      console.error('‚ùå Error getting quality statistics:', error);
      throw error;
    }
  }
}

// Create singleton instance
export const reportQualityMonitor = new ReportQualityMonitor();

// Default export
export default reportQualityMonitor;