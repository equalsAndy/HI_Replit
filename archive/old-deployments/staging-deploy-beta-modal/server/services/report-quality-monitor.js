import { Pool } from 'pg';
import { conversationLoggingService } from './conversation-logging-service.js';
const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});
export class ReportQualityMonitor {
    async analyzeReportQuality(reportContent, userId, reportType, userAssessmentData) {
        const issues = [];
        const reportId = `report-${userId}-${Date.now()}`;
        if (this.isGenericTemplate(reportContent)) {
            issues.push({
                reportId,
                userId,
                issueType: 'generic_template',
                severity: 'critical',
                description: 'Report appears to be a generic template without user-specific data',
                reportLength: reportContent.length,
                hasUserData: false,
                hasSpecificPercentages: false,
                hasPersonalizedContent: false,
                detectedAt: new Date()
            });
        }
        const hasActualData = this.usesActualUserData(reportContent, userAssessmentData);
        if (!hasActualData && userAssessmentData) {
            issues.push({
                reportId,
                userId,
                issueType: 'missing_data',
                severity: 'high',
                description: 'Report does not incorporate available user assessment data',
                reportLength: reportContent.length,
                hasUserData: false,
                hasSpecificPercentages: this.hasSpecificPercentages(reportContent),
                hasPersonalizedContent: this.hasPersonalizedContent(reportContent),
                detectedAt: new Date()
            });
        }
        if (!this.hasSpecificPercentages(reportContent)) {
            issues.push({
                reportId,
                userId,
                issueType: 'low_personalization',
                severity: 'medium',
                description: 'Report lacks specific percentage data from user StarCard assessment',
                reportLength: reportContent.length,
                hasUserData: hasActualData,
                hasSpecificPercentages: false,
                hasPersonalizedContent: this.hasPersonalizedContent(reportContent),
                detectedAt: new Date()
            });
        }
        if (!this.hasPersonalizedContent(reportContent)) {
            issues.push({
                reportId,
                userId,
                issueType: 'low_personalization',
                severity: 'medium',
                description: 'Report lacks personalized content with user-specific examples',
                reportLength: reportContent.length,
                hasUserData: hasActualData,
                hasSpecificPercentages: this.hasSpecificPercentages(reportContent),
                hasPersonalizedContent: false,
                detectedAt: new Date()
            });
        }
        if (issues.length > 0) {
            await this.logQualityIssues(reportId, issues);
            await this.createEscalationForPoorReport(reportId, userId, issues);
        }
        return issues;
    }
    isGenericTemplate(reportContent) {
        const genericIndicators = [
            'Taylor Smith',
            'Acting: 35%',
            'You possess a unique combination of strengths that shapes how you naturally approach',
            'Generated by AllStarTeams Workshop | AST v2.1.0'
        ];
        let genericCount = 0;
        for (const indicator of genericIndicators) {
            if (reportContent.includes(indicator)) {
                genericCount++;
            }
        }
        return genericCount >= 2;
    }
    usesActualUserData(reportContent, userAssessmentData) {
        if (!userAssessmentData)
            return false;
        if (userAssessmentData.starCard) {
            const { thinking, feeling, acting, planning } = userAssessmentData.starCard;
            const thinkingPercent = ((thinking / 100) * 100).toFixed(1);
            const feelingPercent = ((feeling / 100) * 100).toFixed(1);
            const actingPercent = ((acting / 100) * 100).toFixed(1);
            const planningPercent = ((planning / 100) * 100).toFixed(1);
            if (reportContent.includes(thinkingPercent) ||
                reportContent.includes(feelingPercent) ||
                reportContent.includes(actingPercent) ||
                reportContent.includes(planningPercent)) {
                return true;
            }
        }
        if (userAssessmentData.reflections) {
            for (const reflection of Object.values(userAssessmentData.reflections)) {
                if (typeof reflection === 'string' && reflection.length > 20) {
                    const words = reflection.split(' ').slice(0, 5).join(' ');
                    if (reportContent.includes(words)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    hasSpecificPercentages(reportContent) {
        const genericPercentages = ['35%', '25%', '20%', '30%'];
        for (const generic of genericPercentages) {
            if (reportContent.includes(generic)) {
                return false;
            }
        }
        const specificPercentagePattern = /\d+\.\d+%/;
        return specificPercentagePattern.test(reportContent);
    }
    hasPersonalizedContent(reportContent) {
        const personalizationIndicators = [
            'you mentioned',
            'your example of',
            'you described',
            'you reflected',
            'your response about',
            'you shared',
            'you explained'
        ];
        for (const indicator of personalizationIndicators) {
            if (reportContent.toLowerCase().includes(indicator)) {
                return true;
            }
        }
        return false;
    }
    async logQualityIssues(reportId, issues) {
        try {
            for (const issue of issues) {
                await conversationLoggingService.logConversation({
                    personaType: 'star_report',
                    userId: issue.userId,
                    sessionId: reportId,
                    userMessage: `Report quality analysis for user ${issue.userId}`,
                    taliaResponse: `Quality issue detected: ${issue.issueType} - ${issue.description}`,
                    contextData: {
                        reportQualityIssue: true,
                        issueType: issue.issueType,
                        severity: issue.severity,
                        reportLength: issue.reportLength,
                        hasUserData: issue.hasUserData,
                        hasSpecificPercentages: issue.hasSpecificPercentages,
                        hasPersonalizedContent: issue.hasPersonalizedContent
                    },
                    requestData: {
                        reportId,
                        qualityAnalysis: true,
                        requestTimestamp: new Date().toISOString()
                    },
                    responseMetadata: {
                        confidence: 0.9,
                        source: 'metalia_quality_monitor',
                        tokensUsed: 0
                    },
                    conversationOutcome: issue.severity === 'critical' ? 'escalated' : 'completed'
                });
            }
            console.log(`üìä METAlia: Logged ${issues.length} quality issues for report ${reportId}`);
        }
        catch (error) {
            console.error('‚ùå Error logging quality issues:', error);
        }
    }
    async createEscalationForPoorReport(reportId, userId, issues) {
        try {
            const criticalIssues = issues.filter(i => i.severity === 'critical');
            if (criticalIssues.length > 0) {
                await conversationLoggingService.createEscalation({
                    requestingPersona: 'star_report',
                    escalationType: 'error_report',
                    priority: 'high',
                    question: `Poor quality report generated for user ${userId}. Issues detected: ${issues.map(i => i.issueType).join(', ')}`,
                    contextData: {
                        reportId,
                        userId,
                        issues: issues.map(i => ({
                            type: i.issueType,
                            severity: i.severity,
                            description: i.description
                        }))
                    },
                    userMessage: `Report quality analysis for user ${userId}`,
                    attemptedResponse: `Report contained ${issues.length} quality issues`
                });
                console.log(`üö® METAlia: Created escalation for poor quality report ${reportId}`);
            }
        }
        catch (error) {
            console.error('‚ùå Error creating quality escalation:', error);
        }
    }
    async getQualityStatistics(days = 7) {
        try {
            const conversations = await conversationLoggingService.getConversations({
                personaType: 'star_report',
                startDate: new Date(Date.now() - days * 24 * 60 * 60 * 1000),
                endDate: new Date(),
                limit: 1000
            });
            const qualityIssues = conversations.filter(c => c.context_data?.reportQualityIssue === true);
            const issueTypes = qualityIssues.reduce((acc, issue) => {
                const type = issue.context_data?.issueType || 'unknown';
                acc[type] = (acc[type] || 0) + 1;
                return acc;
            }, {});
            const severityCounts = qualityIssues.reduce((acc, issue) => {
                const severity = issue.context_data?.severity || 'unknown';
                acc[severity] = (acc[severity] || 0) + 1;
                return acc;
            }, {});
            return {
                totalReports: conversations.length,
                reportsWithIssues: qualityIssues.length,
                qualityRate: ((conversations.length - qualityIssues.length) / conversations.length * 100).toFixed(1),
                issueTypes,
                severityCounts,
                timeRange: `${days} days`
            };
        }
        catch (error) {
            console.error('‚ùå Error getting quality statistics:', error);
            throw error;
        }
    }
}
export const reportQualityMonitor = new ReportQualityMonitor();
export default reportQualityMonitor;
